# Порівняння Жадібного Алгоритму та Алгоритму Динамічного Програмування

## Жадібний Алгоритм (`find_coins_greedy`)
- **Часова складність:** O(n)
- **Переваги:**
  - Швидкий час виконання.
  - Низька просторова складність.
- **Недоліки:**
  - Не гарантує мінімальної кількості монет для всіх наборів номіналів.

## Алгоритм Динамічного Програмування (`find_min_coins`)
- **Часова складність:** `O(n * m)`, де `n` — сума, яку потрібно видати, а `m` — кількість різних номіналів монет.
- **Переваги:**
  - Гарантує мінімальну кількість монет.
- **Недоліки:**
  - Повільніший час виконання для великих сум.
  - Вища просторова складність.

## Просторова складність
- Жадібний алгоритм: `O(1)` — використовує константну додаткову пам'ять.
- Алгоритм динамічного програмування: `O(n)` — потребує додаткової пам'яті для таблиці розміром `(amount + 1)`.

## Продуктивність при великих сумах
- **Жадібний алгоритм** швидкий та ефективний для великих сум, оскільки його час виконання лінійно залежить від кількості монет, а не від самої суми. Він також використовує мінімальну кількість пам'яті.

- **Алгоритм динамічного програмування** може бути повільнішим для дуже великих сум через квадратичну залежність часу виконання від суми. Однак він гарантує знаходження мінімальної кількості монет, тоді як жадібний алгоритм цього не завжди робить (хоча для стандартних наборів монет, таких як у цьому прикладі, жадібний підхід також знаходить оптимальне рішення).

## Загальні висновки
- Для стандартних наборів монет, таких як [50, 25, 10, 5, 2, 1], жадібний алгоритм ефективний та швидкий, оскільки він завжди знаходить оптимальне рішення.
- Якщо використовуються нестандартні номінали монет, де жадібний підхід може не бути оптимальним, варто застосовувати алгоритм динамічного програмування.
- Для великих сум, де час виконання критичний, жадібний алгоритм буде більш ефективним вибором, якщо він забезпечує коректні результати.
