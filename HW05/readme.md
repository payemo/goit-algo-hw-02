- **Функція `dfs_path`:** Реалізує рекурсивний пошук у глибину, який шукає шлях від початкової вершини до цільової, відвідуючи якомога глибше кожну гілку перед поверненням.
- **Функція `bfs_path`:** Реалізує пошук у ширину, який використовує чергу для відстеження вершин на поточному рівні перед переходом до наступного.
- **Виконання пошуку:** Обидві функції шукають шлях з вершини 'A' до вершини 'E' у графі `G`.

**Аналіз отриманих шляхів:**
- **Шлях DFS:** `['A', 'B', 'C', 'D', 'E']`
  - Алгоритм DFS починає з вершини 'A', йде до 'B', потім до 'C', 'D' і, нарешті, до 'E'.
  - Цей шлях є довшим і не найкоротшим можливим.
- **Шлях BFS:** `['A', 'E']`
  - Алгоритм BFS знаходить найкоротший шлях, оскільки він спочатку перевіряє всіх сусідів поточної вершини.
  - В даному випадку 'A' і 'E' безпосередньо з'єднані, тому BFS швидко знаходить цей шлях.

**Чому шляхи відрізняються:**
- **DFS (Пошук в глибину):**
  - Прагне дослідити якомога глибше кожну гілку графа перед поверненням назад.
  - У нашому випадку DFS спочатку йде по шляху 'A' -> 'B' -> 'C' -> 'D' -> 'E', не помічаючи, що 'E' безпосередньо з'єднана з 'A'.
  - Це відбувається через те, що алгоритм DFS пріоритезує перший знайдений шлях у глибину, який може бути довшим за найкоротший шлях.
- **BFS (Пошук в ширину):**
  - Обходить граф рівнями, спочатку перевіряючи всі вершини на відстані 1 від початкової.
  - Оскільки 'E' є безпосереднім сусідом 'A', BFS одразу знаходить цей найкоротший шлях.
  - Алгоритм BFS гарантує знаходження найкоротшого шляху в графах без ваг.

**Висновки:**
- **Алгоритм DFS** може бути корисним для задач, де потрібно відвідати всі вершини або знайти будь-який шлях до цільової вершини, не обов'язково найкоротший.
- **Алгоритм BFS** є оптимальним для знаходження найкоротшого шляху в незважених графах, оскільки він обходить граф рівнями.
- **Різниця в шляхах** обумовлена принципом роботи кожного алгоритму:
  - **DFS** поглиблюється в граф, що може призвести до довших шляхів.
  - **BFS** розширюється по ширині, що дозволяє знайти найкоротший шлях.

**Практичне значення:**
- **Для транспортної мережі:**
  - **BFS** може використовуватися для пошуку найкоротших маршрутів між районами.
  - **DFS** може бути корисним для обстеження всіх можливих маршрутів, наприклад, для виявлення альтернативних шляхів або аналізу зв'язності мережі.

**Візуалізація графа з позначенням шляхів:**
Щоб краще зрозуміти різницю, можна візуалізувати граф та виділити обидва шляхи.
```
# Візуалізація графа з виділенням шляхів DFS і BFS
pos = nx.spring_layout(G)

# Малюємо всі ребра
all_edges = nx.draw_networkx_edges(G, pos, width=1.0, alpha=0.5, edge_color='gray')

# Малюємо вершини
nx.draw_networkx_nodes(G, pos, node_size=500, node_color='lightblue')

# Малюємо мітки вершин
nx.draw_networkx_labels(G, pos)

# Виділяємо шлях DFS
edge_list_dfs = list(zip(dfs_result, dfs_result[1:]))
dfs_edges = nx.draw_networkx_edges(G, pos, edgelist=edge_list_dfs, width=3, edge_color='red')

# Виділяємо шлях BFS
edge_list_bfs = list(zip(bfs_result, bfs_result[1:]))
bfs_edges = nx.draw_networkx_edges(G, pos, edgelist=edge_list_bfs, width=3, edge_color='green')

# Створення легенди з відповідними мітками та стилями
edge_all_legend = mlines.Line2D([], [], color='gray', alpha=0.5, linewidth=1, label='Ребра графа')
edge_dfs_legend = mlines.Line2D([], [], color='red', linewidth=3, label='Шлях DFS')
edge_bfs_legend = mlines.Line2D([], [], color='green', linewidth=3, label='Шлях BFS')

plt.legend(handles=[edge_all_legend, edge_dfs_legend, edge_bfs_legend], loc='upper right')
plt.axis('off')
plt.show()
```